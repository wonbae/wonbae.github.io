# Sorting(정렬) 종류와 특징

> Bubble, Counting, Selection, Insertion, Quick, Merge, Heap 정렬이 있다.


#### 목표

 * 정렬의 종류를 알아본다.
 * 각 정렬별 특징을 배운다.
 * Big-O notation
 * 코드로 구현해보기





## 1. Bubble Sort (버블 정렬)


>인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식.

**정렬 과정**
1. 첫번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 끝 자리까지 이동
2. 한 단계가 끝나면 가장 큰 원소 또는 가장 작은 원소가 마지막 자리에 위치함



**예제**
![bubble_sort](⁨../gitblog⁩/wonbae.github.io⁩/imgfile⁩/bubblesort.png)


**코드**

C++ 구현


```cpp

	#include<iostream>
	#include<iomanip>
	using namespace std;
	using std::setw;

	void bubble(int list[], int n);
	int main(){
		int i;
		const int len = 5;
		int list[len] = {55,7,78,12,42};

		bubble(list,len);

		for(int i = 0; i < len; i++){
			cout<<setw(4)<<list[i];
		}cout<<endl;

		return 0;
	}

	void bubble(int list[], int n){
		int tem;
		for(int i = 0; i < n-1; i++ ){
			for(int j = 0; j < n-i-1; j++){
				if(list[j] > list[j+1]){
					tem = list[j];
					list[j] = list[j+1];
					list[j+1] = tem;
				}
			}
		}
	}
	#=> 7 12 42 55 78

```


**시간복잡도**

`O(n^2)`


**참고동영상**

[버블소팅](https://www.youtube.com/watch?v=YbsQiiubO74)







## 2. Counting Sort (카운팅 정렬)


>항목들의 순서를 결정하기 위해 집합에서 각 항목이 몇개씩 있는지 카운팅 하여, 선형 시간에 정렬하는 효율적인 알고리즘

**제한사항**
- `정수` 혹은 정수로 표현 가능한 자료에 대해서만 적용 가능
	- 각 항목의 갯수를 카운팅 하기 위해, 정수 항목으로 인덱싱 되는 카운트들의 Array(배열)을 사용하기 때문임
- 카운트들을 위한 충분한 공간을 확보하기 위해서 `집합 내의 가장 큰 정수`를 알아야 함


**정렬과정**
1. 카운팅 배열을 하나 만든다. 입력데이터에 들어있는 숫자들이 몇개씩 들어 있는지 카운팅해야 하기 때문
2. 



**예제**




**코드**







**시간복잡도**

`O(n + k)`
n은 항목의 갯수, k는 정수의 최대값






## 3. Selection Sort (선택 정렬)


- 주어진 자료에서 `가장 작은 값의 원소부터 차례대로` 선택하여 위치를 교환하는 방식
- 주어진 자료에서 N번째로 큰 혹은 작은 원소를 선택하는(Select) 방법
- 최소값, 최대값 혹은 중간값을 찾으라는 문제에 적용


**정렬과정**

 일단 자료를 정렬하고 원하는 N번째 원소를 가져오기
 1. 주어진 리스트 중에서 `최소값을 찾음`
 2. 그 값을 리스트 `맨 앞`에 위치한 값과 `교환`
 3. `맨 처음 위치를 제외한` 나머지 리스트를 대상으로 1 ~ 2 반복



**시간복잡도**

`O(n^2)`




[선택정렬](https://www.youtube.com/watch?v=uCUu3fF5Dws)




## 4. Insertion Sort (삽입 정렬)

**정렬 과정**

**코드**

**시간복잡도**





## 5. Quick Sort (퀵 정렬)
**정렬 과정**

**코드**

**시간복잡도**


[퀵정렬](https://www.youtube.com/watch?v=7BDzle2n47c)






## 6. Merge Sort (병합 정렬)


**정렬 과정**

**코드**

**시간복잡도**


[머지소트](https://www.youtube.com/watch?v=QAyl79dCO_k)






## 7. Heap Sort (힙 정렬)
> 최대/최소 값을 빠르게 찾도록 만들어진 자료구조이다.
> Priority Queue를 Heap으로 구현 가능

### Heap(힙) 이란?
- `최대, 최소 값을 빠르게 찾도록 만들어진 자료구조`이다.
- `전체 자료를 정렬할 때 보다 가장 큰/작은 값 몇개만 필요할 때 가장 유용함.`
- 완전 이진 트리 구조의 자료구조 이다.
- Heap을 사용해 `우선순위 큐를 구현`할 수 있다. (그 외, Sorted Linked List, Array / Unsorted LL, Array 도 가능) 
- 힙 트리에서는 중복을 허용한다(Binary Search Tree 에서는 중복 혀용 X)

- Max Heap(최대 힙)
	- 부모 노드의 값이 자식 노드의 값보다 크거나 같은 완전 이진 트리
- Min Heap(최소 힙)
	- 부모 노드의 값이 자식 노드의 값보다 작거나 같은 완전 이진 트리
	
- `Unstable` 하지만 최악의 경우에도 최적의 성능보장, 추가메모리 X
- 배열을 사용해 힙을 구현


### 시간복잡도
`O(nlogn)`

Heap Tree의 level(depth)가 거의 ㅣog2n(완전 이진트리) 이므로 삽입/삭제 할 때 걸리는 시간이 log2n만큼 걸림. Tree의 Node수가 N개 임으로 전체적으로 O(nlogn)인 거임.

> Quick Sort 와 Merge Sort 랑 같은 시간복잡도를 가진다.
> 하지만 `MergeSort` 와는 다르게 `추가적인 메모리가 필요 없고`
> `QuickSort`와 다르게 `최악의 경우 n^2의 성능보다 안정적이다.`


### 정렬 과정
- 1차원 배열로 구현 할 수 있다.
- 절렬이 안된 요소들을 1차원 배열에 담아둔 뒤 Max Heap Insert(push?)를 통해 차례로 삽입
- Max Heap 으로 구성된 배열에서 최대값부터 삭제하면 내림차순 max heap이 된다.

힙은 완전 이진트리이므로 삽입시에는 가장 마지막 노드 위치에, 추출시에는 루트가 삭제.

`루트 노드의 인덱스를 i` 라고 했을때, 
`왼쪽 자식 노드는 i*2`, `오른쪽은 i*2 + 1 이고`, 
`부모 노드는` 자식노드 index 값을 i 라고 했을때 `i / 2 `이므로 부모와 자식에 대한 접근 연산이 단순 나눗셈, 덧셈으로 구현되어 접근이 편하다.

물론 이 경우 root 노트의 index 값은 1부터 시작합니다. 0부터 시작하는 경우는 부모와 자식에 대한 연산의 값이 조금 달라질 수 있습니다. 
그러나 1부터 시작하는 경우의 장점은, 왼쪽 자식에 대한 접근이 곱하기 2로, 부모에 대한 접근이 나누기 2로 표현되므로 시프트 연산으로 구현할 수 있다는 점입니다.


- 최대 힙 삽입(Max Heap Insert)
	1. 기존 Heap에 새로운 값(노드)가 들어오면 배열 마지막에 삽입한다.
	2. 새로운 노드가 들어오면 부모 노드들과 비교하여 트리를 거슬러 올라가면서 교환 하든 말든 한다.

- 최대 힙 삭제(Max Heap Delete)
	1. 최대값을 반환해야 함으로 root 노드를 삭제
	2. 삭제된 root node 자리에 마지막 노드를 가져와서 대체한다
	3. tree를 내려가며 비교하면서 힙을 재구성 한다.


### 코드
처음에 max-heap으로 전체를 max-heap으로 만든 다음, max 값을 추출(O(logn))함으로써 구현
GeekforGeek code 참조함.

```cpp
	#include <iostream> 
	using namespace std; 

	// To heapify a subtree rooted with node 'root' which is 
	// an index in arr[]. 'n' is size of heap 
	// heap을 구성하기를 heapify라 부름
	void heapify(int arr[], int n, int root) 
	{ 
		int largest = root; // Initialize largest as root 
		int left = 2*root + 1; // or left = (i + 1)*2 - 1 
		int right = 2*root + 2; // or right = (i + 1)*2 

		// If left child is larger than root 
		if (left < n && arr[left] > arr[largest]) 
			largest = left; 

		// If right child is larger than largest so far 
		if (right < n && arr[right] > arr[largest]) 
			largest = right; 

		// If largest is not root 
		if (largest != root) 
		{ 
			swap(arr[root], arr[largest]); 

			// Recursively heapify the affected sub-tree 
			heapify(arr, n, largest); 
		} 
	} 

	// main function to do heap sort 
	void heapSort(int arr[], int n) 
	{ 
		// Build heap (rearrange array) 
		for (int i = n / 2 - 1; i >= 0; i--) 
			heapify(arr, n, i); 

		// One by one extract an element from heap 
		for (int i=n-1; i>=0; i--) 
		{ 
			// Move current root to end 
			swap(arr[0], arr[i]); 

			// call max heapify on the reduced heap 
			heapify(arr, i, 0); 
		} 
	} 

	/* A utility function to print array of size n */
	void printArray(int arr[], int n) 
	{ 
		for (int i=0; i<n; ++i) 
			cout << arr[i] << " "; 
		cout << "\n"; 
	} 

	// Driver program 
	int main() 
	{ 
		int arr[] = {12, 11, 13, 5, 6, 7}; 
		int n = sizeof(arr)/sizeof(arr[0]); 

		heapSort(arr, n); 

		cout << "Sorted array is \n"; 
		printArray(arr, n); 
	} 

```



---
## Big-O Notation(빅오표기법)



### 참고 동영상
---
big-o표기법
[빅오 한글](https://www.youtube.com/watch?v=6Iq5iMCVsXA&t=42s)
[빅오 영문](https://www.youtube.com/watch?v=D6xkbGLQesk)
[빅오 영문](https://www.youtube.com/watch?v=v4cd1O4zkGw)
