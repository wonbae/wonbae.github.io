# Python의 변수선언과 메모리(id) 확인, copy() 모듈 사용법

### 목표

> * Python의 변수선언 방법
* 변수의 메모리값 확인(id)
* copy() 모듈 사용방법

---



### 변수 만드는 방법
---

~~~python
a = 1
b = "hello python"
c = [2,4,6]
~~~
다음 예와같은 a,b,c를 변수라고 한다. `=(assignment)`를 사용하여 대입하듯이 사용한다.
C, Java 처럼 변수의 자료형(int,double...)을 지정해 주지 않아도 된다. 저장된 값을 알아서 파악해 자료형을 알고있다.
~~~
변수명 = 변수에 저장할 값
~~~



### 변수란
---

파이썬에서 사용하는(우리가만드는) `변수는`, `객체를 가리킨다`고 볼 수 있다. 객체란 리스트, 튜플, 딕셔너리와 같은 자료형이라고 생각하면 될꺼같다.
~~~python
a = [2,4,6]
~~~

`=(assignment)`를 사용하여 리스트 [2,4,6]을 a 변수에 담았다. 대입했다. 
`리스트(list) [2,4,6]`은 컴퓨터의 메모리공간 어딘가에 할당되고 그 공간을 `a` 가 가리킨다.
그래서 `id(a)`의 값을 보면 할당된 곳의 주소값을 알 수 있다.

다음과 같이 a변수가 가리키는 메모리 주소를 확인할 수 있다.

{% highlight python %}
a = [2,4,6]
id(a)
#=> 5101027875
{% endhighlight %}


`id 함수`는 Python 내장합수이다. 변수(a)가 가리키고 있는 객체([2,4,6])의 주소를 리턴해 준다.  즉, a가 가리키고 있는 [2,4,6] 이라는 리스트의 주소는 5101027875 임을 알 수 있다.


### 리스트를 복사할때
---

~~~python
a = [1,2,3]
b = a
~~~
a 를 b에 대입했다. 그럼 a와 b는 똑같은 것일까? 똑같다.
이는 a 를 b 에 대입함으로써 둘이 똑같은 메모리공간을 가리킨다는 것이다.
~~~python
id(a)
#=>8301229893
id(b)
#=>8301229893
a is b
#=>True
~~~
a가 가리키는 메모리 공간과 b가 가리키는 메모리 공간이 똑같다는 것을 알 수 있다.

>그래서 a의 값을 바꾸면 b도 동시에 값이 바껴진다. 만약 a 의 값을 그대로 가지는 b를 가지되 따로 놀게 할 순 없을까? *a가 바뀌더라도 b는 영향이 없게 말이다.*
>다음 2가지 방법이 있다.


1. **[:] 이용**
~~~python
a = [2,4,6]
b = a[:]
a[0] = 1
print(a)
#=> [1,4,6] #a
print(b)
#=> [2,4,6] #b
~~~
이처럼 a의 값을 바꾸더라도 b에 영향이 없다.

2. **copy() 모듈 이용**

~~~python
form copy import copy
b = copy(a)
b is a
#=> False
~~~
b = copy(a)는 b = a[:]와 똑같다. 마지막에 b is a 의 반환값이 False임으로 둘은 다른 공간을 가리키고 있다는 것을 알 수 있다.


### 생각해보기
---

`+`를 이용하여 이어붙였다
~~~python
a = [1,2,3]
a = a + [4,5,6]
print(a)
#=> [1,2,3,4,5,6]
~~~

이것과 리스트 함수인 `.extend()`를 사용해서 붙이는 것과 차이가 있을까?
~~~python
a = [1,2,3]
a.extend([4,5,6])
print(a)
#=> [1,2,3,4,5,6]
~~~

>`extend()`를 사용하면 원래 있던 메모리 공간에서 공간만 확장된다.
>확장하기 전 a와 확장한 a의 id()를 보면 똑같은 주소를 가리킨다. 
>반면,
>>`+`를 이용해 이어붙이면 기존의 공간과 다른 새로운 메모리 공간을 만들어서 반환해준다.
>>기존의 a와 +로 이어붙인 후 a의 id()를 확인해보면 다른 메모리 공간을 가리키고 있다.


